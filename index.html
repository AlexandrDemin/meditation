<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Circular Code Generator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            padding: 20px;
            min-height: 100vh;
            color: #000000;
            font-size: 16px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 24px;
            font-weight: 400;
            margin-bottom: 40px;
            letter-spacing: -0.5px;
        }
        
        .section {
            margin-bottom: 60px;
        }
        
        .section h2 {
            font-size: 18px;
            font-weight: 400;
            margin-bottom: 20px;
            color: #333;
        }
        
        .input-group {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        input[type="text"], input[type="number"], input[type="file"] {
            flex: 1;
            min-width: 200px;
            padding: 10px 12px;
            border: none;
            border-bottom: 1px solid #ccc;
            background: transparent;
            color: #000000;
            font-size: 16px;
            transition: border-color 0.2s;
        }
        
        input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-bottom-color: #000;
        }
        
        input[type="number"] {
            max-width: 100px;
            min-width: 80px;
        }
        
        button {
            background: #000000;
            color: #ffffff;
            border: none;
            padding: 10px 24px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        button:hover {
            background: #333;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #svgOutput {
            margin: 30px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 420px;
        }
        
        #svgOutput svg {
            width: 100%;
            height: auto;
            max-width: 400px;
        }
        
        #cameraFeed {
            width: 100%;
            max-width: 100%;
            height: auto;
            background: #f5f5f5;
            margin-top: 20px;
        }
        
        .canvas-container {
            text-align: center;
            margin: 30px 0;
        }
        
        .download-btn {
            background: #fff;
            color: #000;
            border: 1px solid #000;
        }
        
        .download-btn:hover {
            background: #000;
            color: #fff;
        }
        
        .status {
            padding: 12px 0;
            margin: 15px 0;
            font-size: 14px;
            color: #666;
        }
        
        .success {
            color: #000;
        }
        
        .error {
            color: #000;
            font-weight: 500;
        }
        
        .info {
            color: #666;
        }
        
        .camera-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .decode-result {
            margin-top: 20px;
            padding: 15px 0;
            border-top: 1px solid #eee;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #000;
        }
        
        .hidden {
            display: none;
        }
        
        .style-info {
            color: #666;
            font-size: 13px;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            line-height: 1.6;
        }

        canvas#decodedCanvas {
            max-width: 100%;
            background: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Circular Code Generator</h1>
        
        <div class="section">
            <h2>Encode</h2>
            <div class="input-group">
                <input type="text" id="textInput" placeholder="Enter text to encode" maxlength="50">
                <input type="number" id="sizeInput" value="400" min="300" max="800" placeholder="Size">
                <button onclick="encodeText()">Generate</button>
            </div>
            <div id="svgOutput"></div>
            <div class="canvas-container">
                <button onclick="downloadSVG()" class="download-btn">Download SVG</button>
            </div>
            <div id="encodeStatus"></div>
        </div>
        
        <div class="section">
            <h2>Decode with Camera</h2>
            <div class="camera-controls">
                <button id="startCamera" onclick="startCamera()">Start</button>
                <button id="stopCamera" onclick="stopCamera()" disabled>Stop</button>
            </div>
            <video id="cameraFeed" autoplay playsinline muted></video>
            <canvas id="decodingCanvas" width="400" height="400" class="hidden"></canvas>
            <div id="decodeStatus"></div>
            <div id="decodedResult"></div>
        </div>
        
        <div class="section">
            <h2>Decode from File</h2>
            <input type="file" id="imageFile" accept="image/*" onchange="decodeFromFile()">
            <div class="canvas-container">
                <canvas id="decodedCanvas" width="400" height="400"></canvas>
            </div>
        </div>
        
        <div class="style-info">
            Creates hand-drawn style circular patterns where information is encoded in concentric rings with organic variations.
        </div>
    </div>

    <script>
        let stream = null;
        let scanning = false;
        
        class CircularCodeEncoder {
            constructor(size = 400) {
                this.size = size;
                this.center = size / 2;
                this.numRings = 8;
                this.segmentsPerRing = [8, 12, 16, 20, 24, 28, 32, 36];
                this.maxDataBits = this.segmentsPerRing.reduce((a, b) => a + b, 0);
            }
            
            textToBits(text) {
                let bits = '';
                
                const length = Math.min(text.length, 50);
                bits += length.toString(2).padStart(8, '0');
                
                for (let i = 0; i < length; i++) {
                    bits += text.charCodeAt(i).toString(2).padStart(8, '0');
                }
                
                let checksum = 0;
                for (let i = 0; i < text.length; i++) {
                    checksum ^= text.charCodeAt(i);
                }
                bits += checksum.toString(2).padStart(8, '0');
                
                while (bits.length < this.maxDataBits) {
                    bits += '0';
                }
                
                return bits.substring(0, this.maxDataBits);
            }
            
            bitsToText(bits) {
                try {
                    const lengthBits = bits.substring(0, 8);
                    const length = parseInt(lengthBits, 2);
                    
                    if (length === 0 || length > 50) {
                        return null;
                    }
                    
                    let text = '';
                    for (let i = 0; i < length; i++) {
                        const start = 8 + (i * 8);
                        const end = start + 8;
                        
                        if (end > bits.length) break;
                        
                        const charBits = bits.substring(start, end);
                        const charCode = parseInt(charBits, 2);
                        
                        if (charCode < 32 || charCode > 126) {
                            return text;
                        }
                        
                        text += String.fromCharCode(charCode);
                    }
                    
                    return text;
                } catch (e) {
                    console.error('Error decoding:', e);
                    return null;
                }
            }
            
            // Add hand-drawn wiggle to path
            addWiggle(x, y, amplitude = 2) {
                const wiggleX = x + (Math.random() - 0.5) * amplitude;
                const wiggleY = y + (Math.random() - 0.5) * amplitude;
                return { x: wiggleX, y: wiggleY };
            }
            
            // Create a clean arc path
            createArc(centerX, centerY, radius, startAngle, endAngle) {
                const startX = centerX + radius * Math.cos(startAngle);
                const startY = centerY + radius * Math.sin(startAngle);
                const endX = centerX + radius * Math.cos(endAngle);
                const endY = centerY + radius * Math.sin(endAngle);
                
                const largeArcFlag = endAngle - startAngle <= Math.PI ? "0" : "1";
                
                return `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`;
            }
            
            // Create a wiggly arc path
            createWigglyArc(centerX, centerY, radius, startAngle, endAngle, wiggleAmount = 2) {
                const steps = 20; // Number of points along the arc
                let pathData = '';
                
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const angle = startAngle + (endAngle - startAngle) * t;
                    const baseX = centerX + radius * Math.cos(angle);
                    const baseY = centerY + radius * Math.sin(angle);
                    
                    // Add varying wiggle along the arc
                    const wiggle = this.addWiggle(baseX, baseY, wiggleAmount * (1 + Math.random() * 0.5));
                    
                    if (i === 0) {
                        pathData += `M ${wiggle.x} ${wiggle.y}`;
                    } else {
                        // Use quadratic curves for smoother hand-drawn effect
                        const prevAngle = startAngle + (endAngle - startAngle) * ((i - 1) / steps);
                        const prevX = centerX + radius * Math.cos(prevAngle);
                        const prevY = centerY + radius * Math.sin(prevAngle);
                        const controlWiggle = this.addWiggle((prevX + baseX) / 2, (prevY + baseY) / 2, wiggleAmount);
                        pathData += ` Q ${controlWiggle.x} ${controlWiggle.y} ${wiggle.x} ${wiggle.y}`;
                    }
                }
                
                return pathData;
            }
            
            generateSVG(text) {
                const bits = this.textToBits(text);
                
                // Create SVG with distortion filter
                let svg = `<svg width="${this.size}" height="${this.size}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${this.size} ${this.size}">`;
                
                // Define subtle wave distortion filter
                svg += `
                <defs>
                    <filter id="distortion">
                        <feTurbulence baseFrequency="0.02" numOctaves="3" seed="5" />
                        <feDisplacementMap in="SourceGraphic" scale="3" />
                    </filter>
                </defs>`;
                
                // White background
                svg += `<rect width="${this.size}" height="${this.size}" fill="white"/>`;
                
                // Group for all paths with distortion filter applied
                svg += `<g filter="url(#distortion)">`;
                
                let bitIndex = 0;
                
                // Draw clean concentric rings
                for (let ring = 0; ring < this.numRings; ring++) {
                    const segments = this.segmentsPerRing[ring];
                    const radius = 35 + (ring * 22);
                    const strokeWidth = 8;
                    
                    for (let segment = 0; segment < segments; segment++) {
                        const bit = bits[bitIndex] || '0';
                        bitIndex++;
                        
                        if (bit === '1') {
                            const startAngle = (segment / segments) * 2 * Math.PI - Math.PI / 2;
                            const endAngle = ((segment + 0.85) / segments) * 2 * Math.PI - Math.PI / 2;
                            
                            // Create clean arc path
                            const pathData = this.createArc(
                                this.center, 
                                this.center, 
                                radius, 
                                startAngle, 
                                endAngle
                            );
                            
                            // Black strokes - clean paths
                            svg += `<path d="${pathData}" 
                                    stroke="black" 
                                    stroke-width="${strokeWidth}" 
                                    fill="none" 
                                    stroke-linecap="round"/>`;
                        }
                    }
                }
                
                svg += `</g>`; // Close group
                svg += '</svg>';
                return svg;
            }
            
            decode(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                let bits = '';
                const scale = canvas.width / this.size;
                const scaledCenter = { x: canvas.width / 2, y: canvas.height / 2 };
                
                let bitIndex = 0;
                
                for (let ring = 0; ring < this.numRings; ring++) {
                    const segments = this.segmentsPerRing[ring];
                    const radius = (35 + (ring * 22)) * scale;
                    
                    for (let segment = 0; segment < segments; segment++) {
                        const angle = ((segment + 0.4) / segments) * 2 * Math.PI;
                        const x = Math.round(scaledCenter.x + Math.cos(angle) * radius);
                        const y = Math.round(scaledCenter.y + Math.sin(angle) * radius);
                        
                        let totalBrightness = 0;
                        let samples = 0;
                        
                        for (let dx = -3; dx <= 3; dx++) {
                            for (let dy = -3; dy <= 3; dy++) {
                                const sampleX = x + dx;
                                const sampleY = y + dy;
                                
                                if (sampleX >= 0 && sampleX < canvas.width && sampleY >= 0 && sampleY < canvas.height) {
                                    const pixelIndex = (sampleY * canvas.width + sampleX) * 4;
                                    const brightness = (data[pixelIndex] + data[pixelIndex + 1] + data[pixelIndex + 2]) / 3;
                                    totalBrightness += brightness;
                                    samples++;
                                }
                            }
                        }
                        
                        const avgBrightness = samples > 0 ? totalBrightness / samples : 255;
                        const bit = avgBrightness < 128 ? '1' : '0';
                        bits += bit;
                    }
                }
                
                return this.bitsToText(bits);
            }
        }
        
        const encoder = new CircularCodeEncoder();
        
        function encodeText() {
            const text = document.getElementById('textInput').value;
            const size = parseInt(document.getElementById('sizeInput').value) || 400;
            
            if (!text.trim()) {
                showStatus('encodeStatus', 'Please enter text to encode', 'error');
                return;
            }
            
            if (text.length > 50) {
                showStatus('encodeStatus', 'Text too long (max 50 characters)', 'error');
                return;
            }
            
            const customEncoder = new CircularCodeEncoder(size);
            const svg = customEncoder.generateSVG(text);
            
            document.getElementById('svgOutput').innerHTML = svg;
            window.currentSVG = svg;
            
            showStatus('encodeStatus', `Encoded: "${text}"`, 'success');
        }
        
        function downloadSVG() {
            if (!window.currentSVG) {
                alert('Please generate a code first');
                return;
            }
            
            const blob = new Blob([window.currentSVG], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'circular-code.svg';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        async function startCamera() {
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 }
                    }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                const video = document.getElementById('cameraFeed');
                video.srcObject = stream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                document.getElementById('startCamera').disabled = true;
                document.getElementById('stopCamera').disabled = false;
                
                showStatus('decodeStatus', 'Camera active', 'info');
                
                setTimeout(() => {
                    scanning = true;
                    scanFrame();
                }, 500);
                
            } catch (err) {
                console.error('Camera error:', err);
                showStatus('decodeStatus', 'Camera access denied', 'error');
            }
        }
        
        function stopCamera() {
            scanning = false;
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            const video = document.getElementById('cameraFeed');
            video.srcObject = null;
            
            document.getElementById('startCamera').disabled = false;
            document.getElementById('stopCamera').disabled = true;
            
            showStatus('decodeStatus', '', 'info');
        }
        
        function scanFrame() {
            if (!scanning) return;
            
            const video = document.getElementById('cameraFeed');
            const canvas = document.getElementById('decodingCanvas');
            const ctx = canvas.getContext('2d');
            
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.width = Math.min(video.videoWidth, 800);
                canvas.height = Math.min(video.videoHeight, 600);
                
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const testCanvas = document.createElement('canvas');
                const testCtx = testCanvas.getContext('2d');
                testCanvas.width = 400;
                testCanvas.height = 400;
                
                testCtx.drawImage(canvas, 0, 0, 400, 400);
                
                const result = encoder.decode(testCanvas);
                if (result && result.length > 0) {
                    document.getElementById('decodedResult').innerHTML = 
                        `<div class="decode-result">Decoded: ${result}</div>`;
                    showStatus('decodeStatus', 'Success', 'success');
                }
            }
            
            if (scanning) {
                requestAnimationFrame(scanFrame);
            }
        }
        
        function decodeFromFile() {
            const file = document.getElementById('imageFile').files[0];
            if (!file) return;
            
            showStatus('decodeStatus', 'Processing...', 'info');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.getElementById('decodedCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = 400;
                    canvas.height = 400;
                    
                    // Clear canvas with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, 400, 400);
                    
                    // Draw the image
                    ctx.drawImage(img, 0, 0, 400, 400);
                    
                    // Try to decode
                    const result = encoder.decode(canvas);
                    
                    if (result && result.length > 0) {
                        document.getElementById('decodedResult').innerHTML = 
                            `<div class="decode-result">Decoded: "${result}"</div>`;
                        showStatus('decodeStatus', 'Successfully decoded', 'success');
                        
                        // Draw sampling points overlay for debugging
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = 'red';
                        
                        // Show sampling points
                        const scale = 1; // canvas is already 400x400
                        const center = { x: 200, y: 200 };
                        
                        for (let ring = 0; ring < encoder.numRings; ring++) {
                            const segments = encoder.segmentsPerRing[ring];
                            const radius = 35 + (ring * 22);
                            
                            for (let segment = 0; segment < segments; segment++) {
                                const midAngle = ((segment + 0.425) / segments) * 2 * Math.PI - Math.PI / 2;
                                const x = center.x + Math.cos(midAngle) * radius;
                                const y = center.y + Math.sin(midAngle) * radius;
                                
                                // Draw a small circle at each sampling point
                                ctx.beginPath();
                                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                        ctx.globalAlpha = 1;
                    } else {
                        document.getElementById('decodedResult').innerHTML = 
                            `<div class="decode-result">Could not decode - try adjusting the image</div>`;
                        showStatus('decodeStatus', 'Decoding failed', 'error');
                    }
                };
                
                img.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        }
        
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            if (message) {
                element.innerHTML = `<div class="status ${type}">${message}</div>`;
            } else {
                element.innerHTML = '';
            }
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    element.innerHTML = '';
                }, 5000);
            }
        }
        
        // Initialize with example
        window.onload = function() {
            document.getElementById('textInput').value = 'Hello World';
            encodeText();
        };
    </script>
</body>
</html>