<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sacred Geometry Encoder/Decoder</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            color: #000000;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 8px;
            padding: 15px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.8em;
            color: #000000;
            font-weight: 300;
        }
        
        .section {
            margin-bottom: 40px;
            padding: 20px 0;
            background: #ffffff;
        }
        
        .section h2 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #000000;
            font-size: 1.2em;
            font-weight: 400;
        }
        
        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-direction: column;
        }
        
        @media (min-width: 480px) {
            .input-group {
                flex-direction: row;
            }
        }
        
        input[type="text"], input[type="number"], input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #ffffff;
            color: #000000;
            font-size: 16px;
            -webkit-appearance: none;
            transition: border-color 0.2s;
        }
        
        input[type="text"]:focus, input[type="number"]:focus, input[type="file"]:focus {
            outline: none;
            border-color: #000000;
        }
        
        input[type="number"] {
            max-width: 120px;
        }
        
        button {
            width: 100%;
            background: #000000;
            color: #ffffff;
            border: none;
            padding: 14px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            font-size: 16px;
            transition: background 0.2s, transform 0.1s;
            margin-bottom: 8px;
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        @media (min-width: 480px) {
            button {
                width: auto;
                margin-bottom: 0;
            }
        }
        
        button:hover, button:focus {
            background: #333333;
            transform: translateY(-1px);
            outline: none;
        }
        
        button:disabled {
            background: #cccccc;
            color: #999999;
            cursor: not-allowed;
            transform: none;
        }
        
        #svgOutput {
            border-radius: 4px;
            background: white;
            margin: 15px 0;
            width: 100%;
            max-width: 100%;
        }
        
        #svgOutput svg {
            width: 100%;
            height: auto;
            max-width: 400px;
            border-radius: 4px;
        }
        
        #cameraFeed {
            width: 100%;
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            background: #000;
        }
        
        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }
        
        .download-btn {
            background: #ffffff;
            color: #000000;
            border: 1px solid #ddd;
        }
        
        .download-btn:hover {
            background: #f5f5f5;
            transform: translateY(-1px);
        }
        
        .status {
            padding: 12px 16px;
            border-radius: 4px;
            margin: 15px 0;
            font-weight: 400;
            word-break: break-word;
            background: #f8f9fa;
            border-left: 3px solid #ddd;
        }
        
        .success {
            background: #f8f9fa;
            border-left-color: #000000;
            color: #000000;
        }
        
        .error {
            background: #f8f9fa;
            border-left-color: #dc3545;
            color: #dc3545;
        }
        
        .info {
            background: #f8f9fa;
            border-left-color: #6c757d;
            color: #6c757d;
        }
        
        .camera-controls {
            display: flex;
            gap: 8px;
            flex-direction: column;
            margin-bottom: 15px;
        }
        
        @media (min-width: 480px) {
            .camera-controls {
                flex-direction: row;
            }
        }
        
        .decode-result {
            margin-top: 15px;
            padding: 16px;
            border-radius: 4px;
            background: #f8f9fa;
            word-break: break-all;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            border-left: 3px solid #000000;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ú® Sacred Geometry Encoder ‚ú®</h1>
        
        <div class="section">
            <h2>üîÆ Encode Information</h2>
            <div class="input-group">
                <input type="text" id="textInput" placeholder="Enter text to encode (max 50 chars)" maxlength="50">
                <input type="number" id="sizeInput" value="400" min="200" max="800" placeholder="Size">
                <button onclick="encodeText()">Encode</button>
            </div>
            <div class="canvas-container">
                <div id="svgOutput"></div>
                <br>
                <button onclick="downloadSVG()" class="download-btn">Download Sacred Symbol (SVG)</button>
            </div>
            <div id="encodeStatus"></div>
        </div>
        
        <div class="section">
            <h2>üì± Decode with Camera</h2>
            <div class="camera-controls">
                <button id="startCamera" onclick="startCamera()">Start Camera</button>
                <button id="stopCamera" onclick="stopCamera()" disabled>Stop Camera</button>
            </div>
            <video id="cameraFeed" autoplay playsinline muted></video>
            <canvas id="decodingCanvas" width="400" height="400" class="hidden"></canvas>
            <div id="decodeStatus"></div>
            <div id="decodedResult"></div>
        </div>
        
        <div class="section">
            <h2>üñºÔ∏è Decode from Image File</h2>
            <input type="file" id="imageFile" accept="image/*" onchange="decodeFromFile()">
            <div class="canvas-container">
                <canvas id="decodedCanvas" width="400" height="400" style="border-radius: 4px; max-width: 100%;"></canvas>
            </div>
        </div>
        
        <div class="info">
            <strong>Sacred Geometry Encoder:</strong> Creates beautiful minimalist patterns where information is encoded as precise geometric arrangements. Each black circle represents encoded data bits arranged in concentric rings.
        </div>
    </div>

    <script>
        let stream = null;
        let scanning = false;
        
        // Sacred geometry SVG encoding system
        class SacredGeometryEncoder {
            constructor(size = 400) {
                this.size = size;
                this.center = size / 2;
                this.maxRings = 18; // 18 rings for high capacity
                this.bitsPerRing = 16; // 16 segments per ring
                this.maxDataBits = this.maxRings * this.bitsPerRing; // 288 bits total
            }
            
            textToBits(text) {
                let bits = '';
                // Add length header (8 bits)
                const length = Math.min(text.length, 50);
                bits += length.toString(2).padStart(8, '0');
                
                // Add text data - each character is 8 bits (supports full ASCII)
                for (let i = 0; i < length; i++) {
                    bits += text.charCodeAt(i).toString(2).padStart(8, '0');
                }
                
                // Add checksum for error detection (8 bits)
                let checksum = 0;
                for (let i = 0; i < text.length; i++) {
                    checksum ^= text.charCodeAt(i);
                }
                bits += checksum.toString(2).padStart(8, '0');
                
                // Pad to fit our capacity
                while (bits.length < this.maxDataBits) {
                    bits += '0';
                }
                
                return bits.substring(0, this.maxDataBits);
            }
            
            bitsToText(bits) {
                try {
                    console.log('=== DECODING PROCESS ===');
                    console.log('Total bits received:', bits.length);
                    
                    // Extract length (first 8 bits)
                    const lengthBits = bits.substring(0, 8);
                    const length = parseInt(lengthBits, 2);
                    console.log('Length bits:', lengthBits, '‚Üí length:', length);
                    
                    if (length === 0 || length > 50) {
                        console.log('‚ùå Invalid length:', length);
                        console.log('Bit pattern analysis:');
                        console.log('First 32 bits:', bits.substring(0, 32));
                        console.log('Might be bit alignment issue...');
                        return null;
                    }
                    
                    let text = '';
                    console.log('Decoding characters:');
                    
                    // Decode each character
                    for (let i = 0; i < length; i++) {
                        const start = 8 + (i * 8);
                        const end = start + 8;
                        
                        if (end > bits.length) {
                            console.log(`‚ùå Not enough bits for character ${i}`);
                            break;
                        }
                        
                        const charBits = bits.substring(start, end);
                        const charCode = parseInt(charBits, 2);
                        const char = String.fromCharCode(charCode);
                        
                        console.log(`  Char ${i}: ${charBits} ‚Üí ${charCode} ‚Üí "${char}"`);
                        
                        // Validate character code
                        if (charCode < 32 || charCode > 126) {
                            console.log(`‚ùå Invalid character code ${charCode} at position ${i}`);
                            return text; // Return what we have so far
                        }
                        
                        text += char;
                    }
                    
                    console.log('‚úÖ Decoded text:', `"${text}"`);
                    console.log('Text length:', text.length);
                    
                    // Check checksum if available
                    const checksumStart = 8 + (length * 8);
                    if (checksumStart + 8 <= bits.length) {
                        const checksumBits = bits.substring(checksumStart, checksumStart + 8);
                        const storedChecksum = parseInt(checksumBits, 2);
                        
                        let calculatedChecksum = 0;
                        for (let i = 0; i < text.length; i++) {
                            calculatedChecksum ^= text.charCodeAt(i);
                        }
                        
                        console.log('Checksum bits:', checksumBits, '‚Üí', storedChecksum);
                        console.log('Calculated checksum:', calculatedChecksum);
                        
                        if (storedChecksum === calculatedChecksum) {
                            console.log('‚úÖ Checksum valid');
                        } else {
                            console.log('‚ö†Ô∏è Checksum mismatch - possible corruption');
                        }
                    }
                    
                    return text;
                } catch (e) {
                    console.error('‚ùå Error in bitsToText:', e);
                    return null;
                }
            }
            
            decode(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                let bits = '';
                
                // Calculate scaling factors
                const scaleX = canvas.width / this.size;
                const scaleY = canvas.height / this.size;
                const scale = Math.min(scaleX, scaleY);
                const scaledCenter = { x: canvas.width / 2, y: canvas.height / 2 };
                
                console.log('=== DECODING ANALYSIS ===');
                console.log('Canvas:', canvas.width, 'x', canvas.height, 'Scale:', scale);
                
                // Sample each ring with updated spacing
                for (let ring = 0; ring < this.maxRings; ring++) {
                    const baseRadius = this.center - 15 - (ring * 10); // Match encoding spacing
                    const radius = baseRadius * scale;
                    
                    if (radius < 5 * scale) break;
                    
                    console.log(`Decoding Ring ${ring}: radius ${radius.toFixed(1)}`);
                    
                    for (let segment = 0; segment < this.bitsPerRing; segment++) {
                        // Calculate the exact center angle for this segment
                        const centerAngle = (segment + 0.5) / this.bitsPerRing * 2 * Math.PI;
                        const x = Math.round(scaledCenter.x + Math.cos(centerAngle) * radius);
                        const y = Math.round(scaledCenter.y + Math.sin(centerAngle) * radius);
                        
                        // Sample multiple nearby pixels to handle anti-aliasing
                        let totalBrightness = 0;
                        let samples = 0;
                        
                        // Sample in a 3x3 area around the target point
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const sampleX = x + dx;
                                const sampleY = y + dy;
                                
                                if (sampleX >= 0 && sampleX < canvas.width && sampleY >= 0 && sampleY < canvas.height) {
                                    const pixelIndex = (sampleY * canvas.width + sampleX) * 4;
                                    const r = data[pixelIndex];
                                    const g = data[pixelIndex + 1];
                                    const b = data[pixelIndex + 2];
                                    const brightness = (r + g + b) / 3;
                                    totalBrightness += brightness;
                                    samples++;
                                }
                            }
                        }
                        
                        const avgBrightness = samples > 0 ? totalBrightness / samples : 255;
                        
                        // More lenient threshold to handle anti-aliasing
                        const bit = avgBrightness < 180 ? '1' : '0';
                        bits += bit;
                        
                        // Log first ring details
                        if (ring === 0) {
                            console.log(`Ring ${ring}, Seg ${segment}: pos(${x},${y}), avgBrightness=${avgBrightness.toFixed(1)}, bit=${bit}`);
                        }
                    }
                }
                
                console.log('Total bits decoded:', bits.length);
                console.log('First 64 bits:', bits.substring(0, 64));
                
                return this.bitsToText(bits);
            }
        }
        
        const encoder = new SacredGeometryEncoder();
        
        // Function to create organic merged shapes (metaballs effect)
        function drawMetaballCluster(ctx, positions, radius) {
            if (positions.length === 0) return;
            
            // Calculate bounding box for the cluster
            const minX = Math.min(...positions.map(p => p.x)) - radius - 2;
            const maxX = Math.max(...positions.map(p => p.x)) + radius + 2;
            const minY = Math.min(...positions.map(p => p.y)) - radius - 2;
            const maxY = Math.max(...positions.map(p => p.y)) + radius + 2;
            
            // Create a path using marching squares algorithm simulation
            ctx.fillStyle = 'black';
            ctx.beginPath();
            
            // For small clusters, use simple convex hull with rounded corners
            if (positions.length <= 4) {
                drawSmoothHull(ctx, positions, radius);
            } else {
                // For larger clusters, draw individual circles with smooth connections
                positions.forEach((pos, index) => {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Add smooth connections between nearby circles
                positions.forEach(pos1 => {
                    positions.forEach(pos2 => {
                        if (pos1 === pos2) return;
                        const distance = Math.sqrt((pos1.x - pos2.x)**2 + (pos1.y - pos2.y)**2);
                        if (distance <= radius * 2.2) {
                            drawSmoothConnection(ctx, pos1, pos2, radius);
                        }
                    });
                });
            }
        }
        
        function drawSmoothHull(ctx, positions, radius) {
            if (positions.length === 1) {
                ctx.arc(positions[0].x, positions[0].y, radius, 0, 2 * Math.PI);
                return;
            }
            
            // Calculate center point
            const centerX = positions.reduce((sum, p) => sum + p.x, 0) / positions.length;
            const centerY = positions.reduce((sum, p) => sum + p.y, 0) / positions.length;
            
            // Sort positions by angle from center for smooth hull
            const sorted = positions.slice().sort((a, b) => {
                const angleA = Math.atan2(a.y - centerY, a.x - centerX);
                const angleB = Math.atan2(b.y - centerY, b.x - centerX);
                return angleA - angleB;
            });
            
            // Draw smooth hull with rounded corners
            const expandedRadius = radius + 2;
            for (let i = 0; i < sorted.length; i++) {
                const current = sorted[i];
                const next = sorted[(i + 1) % sorted.length];
                
                // Calculate expanded points
                const currentAngle = Math.atan2(current.y - centerY, current.x - centerX);
                const expandedX = current.x + Math.cos(currentAngle) * expandedRadius;
                const expandedY = current.y + Math.sin(currentAngle) * expandedRadius;
                
                if (i === 0) {
                    ctx.moveTo(expandedX, expandedY);
                } else {
                    // Use quadratic curves for smooth connections
                    const controlX = (expandedX + current.x) / 2;
                    const controlY = (expandedY + current.y) / 2;
                    ctx.quadraticCurveTo(controlX, controlY, expandedX, expandedY);
                }
            }
            ctx.closePath();
            ctx.fill();
            
            // Fill in the original circle positions to ensure coverage
            positions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        function drawSmoothConnection(ctx, pos1, pos2, radius) {
            const distance = Math.sqrt((pos1.x - pos2.x)**2 + (pos1.y - pos2.y)**2);
            if (distance <= 0) return;
            
            // Calculate perpendicular offset for smooth connection
            const offsetRatio = Math.max(0, 1 - distance / (radius * 2));
            const offset = radius * offsetRatio * 0.4; // Reduced for tighter connections
            
            const dx = pos2.x - pos1.x;
            const dy = pos2.y - pos1.y;
            const perpX = -dy / distance * offset;
            const perpY = dx / distance * offset;
            
            // Draw smooth connecting shape
            ctx.beginPath();
            ctx.moveTo(pos1.x + perpX, pos1.y + perpY);
            ctx.lineTo(pos2.x + perpX, pos2.y + perpY);
            ctx.lineTo(pos2.x - perpX, pos2.y - perpY);
            ctx.lineTo(pos1.x - perpX, pos1.y - perpY);
            ctx.closePath();
            ctx.fill();
        }
        
        function encodeText() {
            const text = document.getElementById('textInput').value;
            const size = parseInt(document.getElementById('sizeInput').value) || 400;
            
            if (!text.trim()) {
                showStatus('encodeStatus', 'Please enter text to encode', 'error');
                return;
            }
            
            if (text.length > 50) {
                showStatus('encodeStatus', 'Text too long (max 50 characters)', 'error');
                return;
            }
            
            // Create encoder and get bits
            const encoder = new SacredGeometryEncoder(size);
            const bits = encoder.textToBits(text);
            
            // Create canvas for direct pixel manipulation
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Fill with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, size, size);
            
            console.log('=== DIRECT CANVAS ENCODING ===');
            console.log('Text:', text);
            console.log('Bits:', bits);
            console.log('Drawing black circles for 1-bits:');
            
            // Draw clean, simple circles for each 1-bit
            let blackCircleCount = 0;
            for (let ring = 0; ring < encoder.maxRings; ring++) {
                const radius = encoder.center - 15 - (ring * 10);
                if (radius < 5) break;
                
                for (let segment = 0; segment < encoder.bitsPerRing; segment++) {
                    const bitIndex = ring * encoder.bitsPerRing + segment;
                    const bit = bits[bitIndex] || '0';
                    
                    if (bit === '1') {
                        const angle = (segment + 0.5) / encoder.bitsPerRing * 2 * Math.PI;
                        const x = Math.round(encoder.center + Math.cos(angle) * radius);
                        const y = Math.round(encoder.center + Math.sin(angle) * radius);
                        
                        // Draw clean, precise circles
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        blackCircleCount++;
                        
                        if (ring < 2) {
                            console.log(`BLACK at Ring ${ring}, Seg ${segment}: pos(${x},${y})`);
                        }
                    }
                }
            }
            
            console.log(`Total black circles: ${blackCircleCount}`);
            
            // Convert canvas to data URL and create SVG that embeds the image
            const dataUrl = canvas.toDataURL('image/png');
            const svgContent = `<svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                <image href="${dataUrl}" x="0" y="0" width="${size}" height="${size}"/>
            </svg>`;
            
            // Display in SVG output
            const svgOutput = document.getElementById('svgOutput');
            svgOutput.innerHTML = svgContent;
            
            // Store for download
            window.currentSVG = svgContent;
            
            showStatus('encodeStatus', `Encoded "${text}" successfully using direct canvas!`, 'success');
        }
        
        function downloadSVG() {
            if (!window.currentSVG) {
                alert('Please encode some text first!');
                return;
            }
            
            const blob = new Blob([window.currentSVG], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'sacred-geometry-code.svg';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        async function startCamera() {
            try {
                // Stop any existing stream first
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                // Request camera with better mobile settings
                const constraints = {
                    video: {
                        facingMode: 'environment', // Back camera preferred
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 30, max: 60 }
                    }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                const video = document.getElementById('cameraFeed');
                video.srcObject = stream;
                
                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                document.getElementById('startCamera').disabled = true;
                document.getElementById('stopCamera').disabled = false;
                
                showStatus('decodeStatus', 'Camera started. Point at a sacred geometry code...', 'info');
                
                // Start scanning with delay to ensure video is ready
                setTimeout(() => {
                    scanning = true;
                    scanFrame();
                }, 500);
                
            } catch (err) {
                console.error('Camera error:', err);
                showStatus('decodeStatus', 'Camera access denied or not available. Please allow camera permissions.', 'error');
            }
        }
        
        function stopCamera() {
            scanning = false;
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            const video = document.getElementById('cameraFeed');
            video.srcObject = null;
            
            document.getElementById('startCamera').disabled = false;
            document.getElementById('stopCamera').disabled = true;
            
            showStatus('decodeStatus', 'Camera stopped', 'info');
        }
        
        function scanFrame() {
            if (!scanning) return;
            
            const video = document.getElementById('cameraFeed');
            const canvas = document.getElementById('decodingCanvas');
            const ctx = canvas.getContext('2d');
            
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Use video dimensions for better quality
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;
                
                if (videoWidth > 0 && videoHeight > 0) {
                    // Set canvas to match video resolution
                    canvas.width = Math.min(videoWidth, 800);
                    canvas.height = Math.min(videoHeight, 600);
                    
                    // Draw current frame
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // Try multiple regions of the frame for better detection
                    const regions = [
                        { x: 0, y: 0, w: canvas.width, h: canvas.height }, // Full frame
                        { x: canvas.width * 0.1, y: canvas.height * 0.1, w: canvas.width * 0.8, h: canvas.height * 0.8 }, // Center region
                        { x: canvas.width * 0.25, y: canvas.height * 0.25, w: canvas.width * 0.5, h: canvas.height * 0.5 } // Smaller center
                    ];
                    
                    for (const region of regions) {
                        const testCanvas = document.createElement('canvas');
                        const testCtx = testCanvas.getContext('2d');
                        testCanvas.width = 400;
                        testCanvas.height = 400;
                        
                        // Extract and resize region
                        testCtx.drawImage(canvas, region.x, region.y, region.w, region.h, 0, 0, 400, 400);
                        
                        const result = encoder.decode(testCanvas);
                        if (result && result.length > 0) {
                            document.getElementById('decodedResult').innerHTML = 
                                `<div class="decode-result"><strong>‚úÖ Decoded:</strong><br>${result}</div>`;
                            showStatus('decodeStatus', 'Successfully decoded!', 'success');
                            
                            // Flash the screen to indicate success
                            video.style.filter = 'invert(1)';
                            setTimeout(() => {
                                video.style.filter = 'none';
                            }, 200);
                            
                            break; // Found a result, no need to check other regions
                        }
                    }
                }
            }
            
            if (scanning) {
                // Use requestAnimationFrame for smooth scanning
                requestAnimationFrame(scanFrame);
            }
        }
        
        function decodeFromFile() {
            const file = document.getElementById('imageFile').files[0];
            if (!file) return;
            
            showStatus('decodeStatus', 'Processing image...', 'info');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.getElementById('decodedCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Scale canvas for display
                    const maxSize = window.innerWidth > 480 ? 400 : Math.min(window.innerWidth - 40, 300);
                    canvas.width = maxSize;
                    canvas.height = maxSize;
                    canvas.style.width = maxSize + 'px';
                    canvas.style.height = maxSize + 'px';
                    
                    // Clear with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, maxSize, maxSize);
                    
                    // Draw image to display canvas
                    ctx.drawImage(img, 0, 0, maxSize, maxSize);
                    
                    // Create a debug canvas with enhanced contrast
                    const debugCanvas = document.createElement('canvas');
                    const debugCtx = debugCanvas.getContext('2d');
                    debugCanvas.width = 400;
                    debugCanvas.height = 400;
                    
                    // Clear debug canvas with white
                    debugCtx.fillStyle = 'white';
                    debugCtx.fillRect(0, 0, 400, 400);
                    
                    // Draw image with no smoothing for crisp edges
                    debugCtx.imageSmoothingEnabled = false;
                    debugCtx.drawImage(img, 0, 0, 400, 400);
                    
                    // Apply contrast enhancement to eliminate anti-aliasing
                    const imageData = debugCtx.getImageData(0, 0, 400, 400);
                    const data = imageData.data;
                    
                    // Convert all pixels to pure black or white
                    for (let i = 0; i < data.length; i += 4) {
                        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const bw = brightness < 200 ? 0 : 255; // More aggressive threshold
                        data[i] = bw;     // R
                        data[i + 1] = bw; // G  
                        data[i + 2] = bw; // B
                        // Keep alpha as is
                    }
                    
                    debugCtx.putImageData(imageData, 0, 0);
                    
                    // Now decode using the enhanced image
                    const testEncoder = new SacredGeometryEncoder(400);
                    
                    console.log('=== ENHANCED SAMPLING ===');
                    let sampledBits = '';
                    
                    // Get the processed image data
                    const processedData = debugCtx.getImageData(0, 0, 400, 400).data;
                    
                    for (let ring = 0; ring < testEncoder.maxRings; ring++) {
                        const radius = testEncoder.center - 15 - (ring * 10);
                        if (radius < 5) {
                            console.log(`Stopped at ring ${ring}, radius ${radius} too small`);
                            break;
                        }
                        
                        if (ring < 3) console.log(`Processing ring ${ring} at radius ${radius}`);
                        
                        for (let segment = 0; segment < testEncoder.bitsPerRing; segment++) {
                            const angle = (segment + 0.5) / testEncoder.bitsPerRing * 2 * Math.PI;
                            const x = Math.round(testEncoder.center + Math.cos(angle) * radius);
                            const y = Math.round(testEncoder.center + Math.sin(angle) * radius);
                            
                            let bit = '0';
                            if (x >= 0 && x < 400 && y >= 0 && y < 400) {
                                const pixelIndex = (y * 400 + x) * 4;
                                const r = processedData[pixelIndex];
                                const g = processedData[pixelIndex + 1];
                                const b = processedData[pixelIndex + 2];
                                const brightness = (r + g + b) / 3;
                                bit = brightness < 128 ? '1' : '0';
                                
                                if (ring === 0 || (ring < 3 && segment < 4)) {
                                    console.log(`Ring ${ring}, Seg ${segment}: pos(${x},${y}), RGB(${r},${g},${b}), bit=${bit}`);
                                }
                            }
                            sampledBits += bit;
                        }
                    }
                    
                    console.log('Total sampled bits:', sampledBits.length);
                    console.log('Expected max bits:', testEncoder.maxDataBits);
                    
                    // Compare with original text encoding to check alignment
                    const originalText = 'TR3BA7zXEhZb8kzz9H6BYGrudbdxwk7Rsk';
                    const expectedBits = testEncoder.textToBits(originalText);
                    console.log('Expected first 64 bits: ', expectedBits.substring(0, 64));
                    console.log('Actual   first 64 bits: ', sampledBits.substring(0, 64));
                    
                    // Make sure we got enough bits
                    if (sampledBits.length < testEncoder.maxDataBits) {
                        console.log(`‚ö†Ô∏è Only got ${sampledBits.length} bits, expected ${testEncoder.maxDataBits}`);
                        while (sampledBits.length < testEncoder.maxDataBits) {
                            sampledBits += '0';
                        }
                    }
                    
                    console.log('Final bits ready for decode:', sampledBits.length);
                    
                    // Try decoding
                    const result = testEncoder.bitsToText(sampledBits);
                    
                    // Display results
                    if (result && result.length > 0) {
                        document.getElementById('decodedResult').innerHTML = 
                            `<div class="decode-result"><strong>‚úÖ Decoded from file:</strong><br>${result}</div>`;
                        showStatus('decodeStatus', 'File decoded successfully!', 'success');
                    } else {
                        document.getElementById('decodedResult').innerHTML = 
                            `<div class="error">‚ùå Could not decode image. Check console for bit comparison.</div>`;
                        showStatus('decodeStatus', 'Decoding failed. Check console for details.', 'error');
                    }
                };
                
                img.onerror = function() {
                    showStatus('decodeStatus', 'Error loading image file', 'error');
                };
                
                // Handle both SVG and raster images
                if (file.type === 'image/svg+xml') {
                    // For SVG files, read as text first
                    const svgReader = new FileReader();
                    svgReader.onload = function(svgEvent) {
                        const svgText = svgEvent.target.result;
                        const blob = new Blob([svgText], {type: 'image/svg+xml'});
                        const url = URL.createObjectURL(blob);
                        img.src = url;
                    };
                    svgReader.readAsText(file);
                } else {
                    img.src = e.target.result;
                }
            };
            
            reader.onerror = function() {
                showStatus('decodeStatus', 'Error reading file', 'error');
            };
            
            reader.readAsDataURL(file);
        }
        
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="${type}">${message}</div>`;
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    element.innerHTML = '';
                }, 5000);
            }
        }
        
        // Initialize with example string
        window.onload = function() {
            document.getElementById('textInput').value = 'TR3BA7zXEhZb8kzz9H6BYGrudbdxwk7Rsk';
            encodeText();
        };
    </script>
</body>
</html>